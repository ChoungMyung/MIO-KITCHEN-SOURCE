import glob
import os.path as op
import re
import subprocess

from hashlib import md5
from os import walk, getcwd, chdir, symlink, readlink, name as osname, stat, unlink
from pathlib import Path
from shutil import rmtree, copytree
from zipfile import ZipFile, ZIP_DEFLATED, is_zipfile
from .Magisk import Magisk_patch
from .bootimg import unpack_bootimg, repack_bootimg
from .configs import (
    make_ext4fs_bin,
    magiskboot_bin,
    img2simg_bin
)
from src.core.utils import img2sdat
from src.core.imgextractor import Extractor
from src.core.utils import Sdat2img as sdat2img, prog_path

if osname == 'nt':
    from ctypes import windll, wintypes

tool_author = 'affggh and ColdWindScholar'
tool_version = '1.1145141919810'


class prop_utils:
    def __init__(self, prop_file: str):
        path = Path(prop_file)
        if path.exists():
            self.fd = Path(prop_file).open('r+', encoding='utf-8')
        else:
            raise FileExistsError(f"File {prop_file} does not exist!")
        self.prop: dict = {n: v for n, v in self.__loadprop}

    @property
    def __loadprop(self) -> list:
        for __ in self.fd.readlines():
            if __[:1] == '#':
                return
            if '=' not in __:
                continue
            yield __.split('=')

    def getprop(self, key: str) -> str | None:
        return self.prop.get(key, '')

    def setprop(self, key, value) -> None:
        self.prop[key] = value

    def save(self):
        self.fd.seek(0, 0)
        self.fd.truncate()
        for i in self.prop.keys():
            self.fd.write(f'{i}={self.prop.get(i, "")}\n')
        self.fd.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):  # with proputil('build.prop') as p:
        self.save()


class updaterutil:
    def __init__(self, fd):
        # self.path = Path(path)
        self.fd = fd
        if not self.fd:
            raise IOError("fd is not valid!")
        self.content = self.__parse_commands

    @property
    def __parse_commands(self):  # This part code from @libchara-dev
        self.fd.seek(0, 0)  # set seek from start
        commands = re.findall(r'(\w+)\((.*?)\)', self.fd.read().replace('\n', ''))
        parsed_commands = [
            [command, *(arg[0] or arg[1] or arg[2] for arg in re.findall(r'(?:"([^"]+)"|(\b\d+\b)|(\b\S+\b))', args))]
            for command, args in commands]
        return parsed_commands

    def generate(self, author: str, version: str, partitions: dict):  # This part code from @libchara-dev
        def add_quotes_if_needed(arg):
            return arg if arg.isdigit() else f'"{arg}"'

        if not partitions.get("system") or not partitions.get("boot"):
            return None
        # 将多行项目合并为单行
        self.fd.seek(0, 0)
        updater_script = self.fd.read()
        updater_script = updater_script.replace('\n', '')

        pattern = r'(\w+)\((.*?)\)'
        commands = re.findall(pattern, updater_script)

        # 筛选并保留symlink、set_metadata_recursive和set_metadata命令
        filtered_commands = [
            (command, *(arg[0] or arg[1] or arg[2] for arg in re.findall(r'(?:"([^"]+)"|(\b\d+\b)|(\b\S+\b))', args)))
            for command, args in commands if command in {'symlink', 'set_metadata_recursive', 'set_metadata'}]

        # 将命令和参数转换为字符串
        updater_script_content = [f"{command}({', '.join(map(add_quotes_if_needed, args))});" for command, *args in
                                  filtered_commands]

        full_commands = [
            'ui_print("");',
            'ui_print("======== Auto Generated By MTK PORT TOOL ========");',
            f"ui_print(\"- Author: {author}\");",
            f"ui_print(\"- Version: {version}\");",
            'ui_print("- MTK PORT TOOL Info below:");'
            f"ui_print(\"    TOOL Author: {tool_author}\");",
            f"ui_print(\"    TOOL Version: {tool_version}\");",
            'ui_print("=================================================");',
            # unmount before flash
            'ifelse(is_mounted("/system"), unmount("/system"));',
            # format system
            f"run_program(\"mke2fs\", \"{partitions['system']}\");",
            'format("ext4", "EMMC", "/dev/block/mmcblk0p4", "0", "/system");',
            "set_progress(0.1);",
            # mount system -> /system
            'ui_print("- Mounting system partition...");',
            f'mount("ext4", "EMMC", "{partitions["system"]}", "/system", "max_batch_time=0,commit=1,data=ordered,barrier=1,errors=panic,nodelalloc");',
            # extract system -> /system
            'ui_print("- Extract system conditionally...");',
            "set_progress(0.2);",
            'package_extract_dir("system", "/system");',
            "set_progress(0.5);",
            # create symlinks and setup metadata
            'ui_print("- Create symlinks and setup metadata...");',
            *updater_script_content,
            "set_progress(0.8);",
            'ui_print("- Flash boot image...");',
            f'package_extract_file("boot.img", "{partitions["boot"]}");',
            "set_progress(0.9);",
            'ui_print("- Done!");',
            # every thing done, now unmount system
            'unmount("/system");',
            "set_progress(1);",
        ]
        return "\n".join(full_commands)


def compress_zip(zippath: str, indir: str):
    with ZipFile(zippath, 'w', ZIP_DEFLATED) as zipf:
        for root, dirs, files in walk(indir):
            for file in files:
                file_path = op.join(root, file)
                zipf.write(file_path, op.relpath(op.abspath(file_path), op.abspath(indir)))


class bootutil:
    def __init__(self, bootpath):
        self.bootpath = op.abspath(bootpath)
        self.bootdir = op.dirname(self.bootpath)
        self.retcwd = getcwd()

    def unpack(self):
        chdir(self.bootdir)
        unpack_bootimg(self.bootpath)
        chdir(self.retcwd)

    def repack(self):
        chdir(self.bootdir)
        print(getcwd())
        with open("bootinfo.txt", encoding='ascii') as f:
            (
                base,
                ramdisk_addr,
                second_addr,
                tags_addr,
                page_size,
                name,
                cmdline,
                padding_size,
            ) = [i.lstrip("\x00").rstrip().split(':')[1] for i in iter(f.readline, "")]
        repack_bootimg(base, cmdline, page_size, padding_size, None)
        chdir(self.retcwd)

    def __entry__(self):
        return self

    def __exit__(self, *vars_):
        chdir(self.retcwd)


class portutils:
    def __init__(self, items: dict, bootimg: str, sysimg: str, portzip: str, genimg: bool = False):
        self.items = items
        self.sysimg = sysimg
        self.bootimg = bootimg
        self.portzip = portzip
        self.genimg = genimg  # if you want system.img
        self.outdir = Path("out")
        if not self.outdir.exists():
            self.outdir.mkdir(parents=True)
        if not self.__check_exist:
            print("Not All Files Exists.")
            return

        # sdat
        self.sdat = False

    @property
    def __check_exist(self) -> bool:
        for i in (self.sysimg, self.bootimg, self.portzip):
            if not Path(i).exists():
                return False
        return True

    @staticmethod
    def execv(cmd, verbose=False):
        if verbose:
            print("Run command：\n", *cmd if isinstance(cmd, list) else cmd)
        creationflags = subprocess.CREATE_NO_WINDOW if osname == 'nt' else 0
        try:
            ret = subprocess.run(cmd,
                                 shell=False,
                                 # stdin=subprocess.PIPE,
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.STDOUT,
                                 creationflags=creationflags
                                 )
        except (Exception, BaseException):
            print("! Cannot execute program\n")
            return -1
        if verbose:
            print("Result：\n", ret.stdout.decode('utf-8', errors='ignore'))
        return ret.returncode

    def __decompress_portzip(self):
        outdir = Path("tmp/rom")
        if outdir.exists():
            rmtree(outdir)
        outdir.mkdir(parents=True)
        print(f"Unpacking port rom...")
        if not is_zipfile(self.portzip):
            print("The file is not zip, please select a zip file.")
            return
        ZipFile(self.portzip, 'r').extractall(outdir)

    def __port_boot(self) -> bool:
        def __replace(src: Path, dest: Path):
            print(f"Replace boot {src} -> {dest}...")
            return dest.write_bytes(src.read_bytes())

        basedir = Path("tmp/base")
        portdir = Path("tmp/port")
        # make new dir
        print("Mkdir boot port directory")
        if basedir.exists():
            rmtree(basedir)
        if portdir.exists():
            rmtree(portdir)

        basedir.mkdir(parents=True)
        portdir.mkdir(parents=True)

        # copy imgs
        print("Copy/Unzip images")
        basedir.joinpath("boot.img").absolute().write_bytes(Path(self.bootimg).read_bytes())
        base = basedir.joinpath("boot.img")
        try:
            ZipFile(self.portzip, 'r').extract("boot.img", "tmp/port/")
        except (Exception, BaseException):
            print("Error: Cannot unpack boot.img from port rom root.")
            return False
        port = Path(portdir.joinpath("boot.img").absolute())
        # port.write_bytes(Path("tmp/rom/boot.img").read_bytes())

        # unpack boot.img
        print("Unpacks boot Image")
        bootutil(base).unpack()
        bootutil(port).unpack()

        # start to port boot
        for item in self.items['flags']:
            item_flag = self.items['flags'][item]
            if not item_flag:
                continue
            match item:
                case 'replace_kernel':
                    for i in self.items['replace']['kernel']:
                        if basedir.joinpath(i).exists():
                            print(f"Replaces kernel {i}")
                            __replace(basedir.joinpath(i), portdir.joinpath(i).absolute())
                case 'replace_fstab':
                    for i in self.items['replace']['fstab']:
                        if basedir.joinpath(i).exists():
                            print(f"Replaces part tables {i}")
                            __replace(basedir.joinpath(i), portdir.joinpath(i).absolute())
                case 'selinux_permissive':
                    if portdir.joinpath("bootinfo.txt").exists():
                        with portdir.joinpath("bootinfo.txt").open("r+") as f:
                            lines = [i.rstrip() for i in f.readlines()]
                            # f.truncate(0)
                            flag = False
                            for i in lines:
                                if "androidboot.selinux=permissive" in i:
                                    print("selinux is permissive already，do nothing.")
                                    flag = True
                            if flag:
                                continue
                            else:
                                f.truncate(0)
                                for i in lines:
                                    if i.startswith("cmdline:"):
                                        print("set selinux permissive")
                                        f.write(i + " androidboot.selinux=permissive\n")
                                    else:
                                        f.write(i + '\n')
                case 'enable_adb':
                    if portdir.joinpath("inidrd/default.prop").exists():
                        print("open adb and debug")
                        with prop_utils(str(portdir.joinpath("inidrd/default.prop"))) as p:
                            kv = [
                                ('ro.secure', '0'),
                                ('ro.adb.secure', '0'),
                                ('ro.debuggable', '1'),
                                ('persist.sys.usb.config', 'mtp,adb')
                            ]
                            for key, value in kv:
                                p.setprop(key, value)

        # repack boot
        print("Repacks boot image")
        bootutil(str(port)).repack()
        to = Path("tmp/rom/boot.img")
        __replace(Path(portdir.joinpath("boot-new.img")), to)
        # patch with magisk
        if self.items.get("patch_magisk"):
            if op.isfile(self.items.get("magisk_apk")):
                with Magisk_patch(str(to), '', magiskboot=magiskboot_bin, MAGISAPK=self.items['magisk_apk'],
                                  PATCH_ARCH=self.items['target_arch']) as m:
                    m.auto_patch()
                    if m.gen:
                        __replace(m.gen, to)
                        unlink(m.gen)
            else:
                print(f"{self.items['magisk_apk']} not found")
        return True

    def __port_system(self):
        def __replace(val: str):
            print(f"Replaces {str(base_prefix)}/{val} -> {str(port_prefix)}/{val}...")
            if "*" in val:  # 匹配通配符
                for file in glob.glob(op.join(str(base_prefix), val)):
                    relfile = op.relpath(file, str(base_prefix))
                    print(f"\t$base/{relfile} -> $port/{relfile}")
                    port_prefix.joinpath(relfile).write_bytes(
                        base_prefix.joinpath(relfile).read_bytes()
                    )
            elif base_prefix.joinpath(val).is_dir():
                if port_prefix.joinpath(val).exists():
                    rmtree(port_prefix.joinpath(val))
                copytree(base_prefix.joinpath(val),
                         port_prefix.joinpath(val))
            else:
                port_prefix.joinpath(val).write_bytes(
                    base_prefix.joinpath(val).read_bytes()
                )
        print("Delect system md5 verifier.")
        with open(self.sysimg, 'rb') as f:
            md5filter = md5()
            for chunk in iter(lambda: f.read(4096), b""):
                md5filter.update(chunk)
            sysmd5 = md5filter.hexdigest()
        md5path = Path("base/system.md5")
        if not md5path.exists():
            md5path.parent.mkdir(parents=True, exist_ok=True)
            md5fd = md5path.open("w")
            md5fd.write(sysmd5)
            readmd5 = ''
        else:
            md5fd = md5path.open("r+")
            readmd5 = md5fd.readline().rstrip()
        md5fd.close()
        if sysmd5 == readmd5 and Path("base/system").exists():
            unpack_flag = False
            print("Delected system unpacked，skip unpacking.")
        else:
            unpack_flag = True
            md5path.parent.mkdir(parents=True, exist_ok=True)
            syspath = Path("base/system")
            configpath = Path("base/config")
            if syspath.exists():
                rmtree("base/system")
            if configpath.exists():
                rmtree("base/config")
        if unpack_flag:
            print("Unpacking system image... ", end='')
            Extractor().main(self.sysimg, "base/system", 'base')
            print("Done!")

        if Path("tmp/rom/system.new.dat").exists():
            print("Delected system.new.dat，Converting...")
            self.sdat = True
            with open("tmp/rom/system.transfer.list") as t:
                self.sdat_ver = int(t.readline().rstrip("\n"))
            sdat2img("tmp/rom/system.transfer.list", "tmp/rom/system.new.dat", "tmp/rom/system.img")
            print("Unpacking target system images...")
            Extractor().main("tmp/rom/system.img", "tmp/rom/system", 'tmp/rom')

        base_prefix = Path("base/system")
        port_prefix = Path("tmp/rom/system")
        for item in self.items['flags']:
            item_flag = self.items[item]
            if not item_flag:
                continue
            if item == 'replace_kernel' or item == 'replace_fstab':
                continue
            if item.startswith("replace_"):
                for i in self.items['replace'][item.split('_')[1]]:
                    if base_prefix.joinpath(i).exists() or ("*" in i):
                        __replace(i)
                    else:
                        print(f"Warning: {i} not found in baserom，maybe its not a big problem")
                continue
            match item:
                case 'single_simcard' | 'dual_simcard':
                    print(f"Modifying config [{'Single SimCard' if item == 'single_simcard' else 'Double SimCard'}]")
                    with prop_utils(str(port_prefix.joinpath("build.prop"))) as p:
                        kv = [
                            ('persist.multisim.config', 'ss' if item == 'single_simcard' else 'dsds'),
                            ('persist.radio.multisim.config', 'ss' if item == 'single_simcard' else 'dsds'),
                            ('ro.telephony.sim.count', '1' if item == 'single_simcard' else '2'),
                            ('persist.dsds.enabled', 'false' if item == 'single_simcard' else 'true'),
                            ('ro.dual.sim.phone', 'false' if item == 'single_simcard' else 'true'),
                        ]
                        for key, value in kv:
                            p.setprop(key, value)
                case 'fit_density':
                    print(f"Get dpi from base rom and write to port rom")
                    with prop_utils(str(port_prefix.joinpath("build.prop"))) as pp, \
                            prop_utils(str(base_prefix.joinpath("build.prop"))) as bp:
                        print(f"Modified port rom build.prop dpi:{bp.getprop('ro.sf.lcd_density')}")
                        pp.setprop('ro.sf.lcd_density', bp.getprop('ro.sf.lcd_density'))
                case 'change_timezone' | 'change_locale' | 'change_model':
                    change_type = item.split('_')[1]
                    keys = []
                    match change_type:
                        case 'timezone':
                            keys = [
                                'persist.sys.timezone',
                            ]
                        case 'locale':
                            keys = [
                                'ro.product.locale',
                            ]
                        case 'model':
                            keys = [
                                'ro.product.manufacturer',
                                'ro.build.product',
                                'ro.product.model',
                                'ro.product.device',
                                'ro.product.board',
                                'ro.product.brand',
                            ]
                    with prop_utils(str(port_prefix.joinpath("build.prop"))) as pp, \
                            prop_utils(str(base_prefix.joinpath("build.prop"))) as bp:
                        for key in keys:
                            value = bp.getprop(key)
                            print(f"修改移植包build.prop键值 [{key}]:[{value}]")
                            pp.setprop(key, value)
        return True

    def __pack_rom(self):
        for item in self.items['flags']:
            item_flag = self.items['flags'][item]
            if not item_flag:
                continue
            match item:
                case 'use_custom_update-binary':
                    print("使用提供的update-binary以解决在twrp刷入报错的问题")
                    Path("tmp/rom/META-INF/com/google/android/update-binary").write_bytes(
                        Path(f"{prog_path}/bin/update-binary").read_bytes())
                case 'generate_script':
                    print("自动重新生成刷机脚本解决一些莫名奇妙的问题...")
                    if (not self.sdat) or (len(self.items['partitions']) != 0):
                        updater = Path("tmp/rom/META-INF/com/google/android/updater-script")
                        if updater.exists():
                            with updater.open('r+', encoding='utf-8', newline='\n') as f:
                                # try to get author
                                author = self.items.get('author')
                                version = self.items.get('version')
                                if not author:
                                    author = tool_author
                                if not version:
                                    version = tool_version
                                new_script = updaterutil(f).generate(author, version, self.items['partitions'])
                                if new_script:
                                    f.seek(0, 0)
                                    f.truncate()
                                    f.write(new_script)
                                    print("Script Generated Successfully...")
                                else:
                                    print("Script Generated Failed...")
                        else:
                            print("Flash Script Not Found...")
                    else:
                        print("刷机包可能是sdat格式或者你的partitions里没指定system和boot")
        print("Packing to sdcard flash rom.....", end='')
        outpath = Path(f"out/{op.basename(self.portzip)}")
        if outpath.exists():
            outpath.unlink()

        if self.sdat:
            print("Packing to sdat...")
            print("Generating system image...")
            config_dir = Path("tmp/rom/config")
            # if config_dir.exists():
            #    rmtree(config_dir)
            # config_dir.mkdir(parents=True)

            # 去重
            with config_dir.joinpath("system_file_contexts").open('r+') as fc:
                fc_info = [i.rstrip() for i in iter(fc.readline, "")]
                new_fc_info = []
                for i in fc_info:
                    if i not in new_fc_info:
                        new_fc_info.append(i)
                fc.seek(0, 0)
                fc.truncate(0)
                fc.write("\n".join(new_fc_info))

            fs_label = [["/", '0', '0', '0755'], ["/lost\\+found", '0', '0', '0700']]
            print("Add lost files and promissions")
            fs_files = [i[0] for i in fs_label]
            for root, dirs, files in walk("tmp/rom/system"):
                if "tmp/install" in root.replace('\\', '/'):
                    continue  # skip lineage spec
                for d in dirs:
                    unix_path = op.join(
                        op.join("/system", op.relpath(op.join(root, d), "tmp/rom/system")).replace("\\", "/")
                    ).replace("[", "\\[")
                    if unix_path not in fs_files:
                        fs_label.append([unix_path.lstrip('/'), '0', '0', '0755'])
                for file in files:
                    unix_path = op.join(
                        op.join("/system", op.relpath(op.join(root, file), "tmp/rom/system")).replace("\\", "/")
                    ).replace("[", "\\[")
                    if unix_path not in fs_files:
                        link = self.__readlink(op.join(root, file))
                        if link:
                            fs_label.append(
                                [unix_path.lstrip('/'), '0', '2000', '0755', link])
                        else:
                            if "bin/" in unix_path:
                                mode = '0755'
                            else:
                                mode = '0644'
                            fs_label.append(
                                [unix_path.lstrip('/'), '0', '2000', mode])
            fs_config = config_dir.joinpath("system_fs_config").open('w', newline='\n')
            fs_label.sort()
            for fs in fs_label:
                fs_config.write(" ".join(fs) + '\n')
            fs_config.close()

            fit_size = self.__pack_fit_size()
            sys_size = stat(self.sysimg).st_size

            make_ext4fs_cmd = [
                make_ext4fs_bin,
                '-s',  # sparse image
                '-J',  # has journal
                '-T', '1',  # custom mtime
                '-l', f'{sys_size if sys_size >= fit_size else fit_size}',  # pack size
                '-C', f"{str(config_dir.joinpath('system_fs_config'))}",
                '-S', f"{str(config_dir.joinpath('system_file_contexts'))}",
                '-L', 'system', '-a', 'system',
                "out/system_raw.img", "tmp/rom/system",
            ]
            self.execv(make_ext4fs_cmd, verbose=True)

            # convert to simg
            self.execv([img2simg_bin, "out/system_raw.img", "out/system.img"])

            if op.isdir("tmp/rom/system"):
                rmtree("tmp/rom/system")
            if op.isdir("tmp/rom/config"):
                rmtree("tmp/rom/config")
            if op.isfile("tmp/rom/system.transfer.list"):
                unlink("tmp/rom/system.transfer.list")

            img2sdat("out/system.img", "tmp/rom", self.sdat_ver)
            if op.isfile("tmp/rom/system.img"):
                print("Removes useless system image...")
                unlink("tmp/rom/system.img")
        compress_zip(str(outpath), "tmp/rom/")
        print("Done！")
        return

    @staticmethod
    def __pack_fit_size():
        total = 0
        for root, dirs, files in walk("tmp/rom/system"):
            for file in files:
                total += stat(op.join(root, file)).st_size
        return total * 1.2

    @staticmethod
    def __readlink(dest: str):
        if osname == 'nt':
            with open(dest, 'rb') as f:
                if f.read(10) == b'!<symlink>':
                    return f.read().decode('utf-16').rstrip('\0')
                else:
                    return None
        else:
            try:
                readlink(dest)
            except (Exception, BaseException):
                return None

    def __pack_img(self):
        def __symlink(src_: str, dest: str):
            def setSystemAttrib(path: str) -> wintypes.BOOL:
                return windll.kernel32.SetFileAttributesA(path.encode('gb2312'), wintypes.DWORD(0x4))

            print(f"Create symlink [{src_}] -> [{dest}]")
            pdest = Path(dest)
            if not pdest.parent.exists():
                pdest.parent.mkdir(parents=True)
            if osname == 'nt':
                with open(dest, 'wb') as f:
                    f.write(
                        b"!<symlink>" + src_.encode('utf-16') + b'\0\0')
                setSystemAttrib(dest)
            else:
                symlink(src_, dest)

        print("Output will be packed as system image")
        updater = Path("tmp/rom/META-INF/com/google/android/updater-script")
        config_dir = Path("tmp/config")
        if config_dir.exists():
            rmtree(config_dir)
        config_dir.mkdir(parents=True)

        fs_label = [["/", '0', '0', '0755'], ["/lost\\+found", '0', '0', '0700']]
        fc_label = [['/', 'u:object_r:system_file:s0'], ['/system(/.*)?', 'u:object_r:system_file:s0']]
        if not updater.exists():
            print(f"Error: flash script not found")
            return

        print("Parsing flash script...")
        contents = updaterutil(updater.open('r', encoding='utf-8')).content
        romprefix = Path("tmp/rom/")
        last_fpath = ''
        for content in contents:
            command, *args = content
            match command:
                case 'symlink':
                    src, *targets = args
                    for target in targets:
                        __symlink(src, str(romprefix.joinpath(target.lstrip('/'))))
                case 'set_metadata' | 'set_metadata_recursive':
                    dirmode = False if command == 'set_metadata' else True
                    fpath, *fargs = args

                    fpath = fpath.replace("+", "\\+").replace("[", "\\[").replace('//', '/')
                    if fpath == last_fpath:
                        continue  # skip same path
                    # initial
                    uid, gid, mode, extra = '0', '0', '644', ''
                    selinux_label = 'u:object_r:system_file:s0'  # common system selable
                    for index, farg in enumerate(fargs):
                        match farg:
                            case 'uid':
                                uid = fargs[index + 1]
                            case 'gid':
                                gid = fargs[index + 1]
                            case 'mode' | 'fmode' | 'dmode':
                                if dirmode and farg == 'dmode':
                                    mode = fargs[index + 1]
                                else:
                                    mode = fargs[index + 1]
                            case 'capabilities':
                                # continue
                                if fargs[index + 1] == '0x0':
                                    extra = ''
                                else:
                                    extra = 'capabilities=' + fargs[index + 1]
                            case 'selabel':
                                selinux_label = fargs[index + 1]
                    fs_label.append(
                        [fpath.lstrip('/'), uid, gid, mode, extra])
                    fc_label.append(
                        [fpath, selinux_label])
                    last_fpath = fpath

        # Patch fs_config
        print("Add lost fs config and selinux context")
        fs_files = [i[0] for i in fs_label]
        for root, dirs, files in walk("tmp/rom/system"):
            if "tmp/install" in root.replace('\\', '/'):
                continue  # skip lineage spec
            for d in dirs:
                unix_path = op.join(
                    op.join("/system", op.relpath(op.join(root, d), "tmp/rom/system")).replace("\\", "/")
                ).replace("[", "\\[")
                if unix_path not in fs_files:
                    fs_label.append([unix_path.lstrip('/'), '0', '0', '0755'])
            for file in files:
                unix_path = op.join(
                    op.join("/system", op.relpath(op.join(root, file), "tmp/rom/system")).replace("\\", "/")
                ).replace("[", "\\[")
                if unix_path not in fs_files:
                    link = self.__readlink(op.join(root, file))
                    if link:
                        fs_label.append(
                            [unix_path.lstrip('/'), '0', '2000', '0755', link])
                    else:
                        if "bin/" in unix_path:
                            mode = '0755'
                        else:
                            mode = '0644'
                        fs_label.append(
                            [unix_path.lstrip('/'), '0', '2000', mode])

        # generate config
        print("Generating fs_config and file_contexts")
        fs_config = config_dir.joinpath("system_fs_config").open('w', newline='\n')
        file_contexts = config_dir.joinpath("system_file_contexts").open('w', newline='\n')
        fs_label.sort()
        fc_label.sort()
        for fs in fs_label:
            fs_config.write(" ".join(fs) + '\n')
        for fc in fc_label:
            file_contexts.write(" ".join(fc) + '\n')
        fs_config.close()
        file_contexts.close()

        fit_size = self.__pack_fit_size()
        sys_size = stat(self.sysimg).st_size
        make_ext4fs_cmd = [
            make_ext4fs_bin,
            # '-s', # sparse image
            '-J',  # has journal
            '-T', '1',  # custom time
            '-l', f'{sys_size if sys_size >= fit_size else fit_size}',  # pack size
            '-C', f"{str(config_dir.joinpath('system_fs_config'))}",
            '-S', f"{str(config_dir.joinpath('system_file_contexts'))}",
            '-L', 'system', '-a', 'system',
            "out/system.img", "tmp/rom/system",
        ]
        self.execv(make_ext4fs_cmd, verbose=True)
        Path("out/boot.img").write_bytes(Path("tmp/rom/boot.img").read_bytes())
        print("Packed！\n"
              "output boot is [out/boot.img]\n"
              "output system is [out/system.img]")
        self.clean()
        return

    def start(self):
        self.__decompress_portzip()
        self.__port_boot()
        self.__port_system()
        if self.genimg:
            self.__pack_img()
        else:
            self.__pack_rom()

    @staticmethod
    def clean():
        print("Port Done, Cleaning Temp...")
        if Path("tmp").exists():
            rmtree("tmp")
